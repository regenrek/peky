#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const cp = require('child_process');

const PROJECT = 'peky';
const DIST_PROJECT = 'peky';
const BIN = 'peky';
const REPO_HTTP = 'https://github.com/regenrek/peky';
const REPO_GIT = 'git+https://github.com/regenrek/peky.git';

const ROOT = path.resolve(__dirname, '..');
const DIST_DIR = path.join(ROOT, 'dist');
const PACKAGES_DIR = path.join(ROOT, 'packages');

function println(msg) {
  process.stdout.write(String(msg) + '\n');
}

function eprintln(msg) {
  process.stderr.write(String(msg) + '\n');
}

function die(msg) {
  eprintln('build-npm-packages: ' + msg);
  process.exit(1);
}

function normalizeVersion(v) {
  const s = String(v || '').trim();
  return s.startsWith('v') ? s.slice(1) : s;
}

function readTextIfExists(p) {
  try {
    return fs.readFileSync(p, 'utf8');
  } catch {
    return null;
  }
}

function rmrf(targetPath) {
  if (!fs.existsSync(targetPath)) return;

  if (fs.rmSync) {
    fs.rmSync(targetPath, { recursive: true, force: true });
    return;
  }

  const stat = fs.lstatSync(targetPath);
  if (stat.isDirectory()) {
    for (const entry of fs.readdirSync(targetPath)) {
      rmrf(path.join(targetPath, entry));
    }
    fs.rmdirSync(targetPath);
    return;
  }

  fs.unlinkSync(targetPath);
}

function mkdirp(p) {
  fs.mkdirSync(p, { recursive: true });
}

function copyDir(src, dest) {
  if (!fs.existsSync(src)) return;
  mkdirp(dest);
  for (const entry of fs.readdirSync(src, { withFileTypes: true })) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDir(srcPath, destPath);
      continue;
    }
    if (entry.isFile()) {
      fs.copyFileSync(srcPath, destPath);
      chmodExec(destPath);
    }
  }
}

function writeJSON(filePath, obj) {
  fs.writeFileSync(filePath, JSON.stringify(obj, null, 2) + '\n');
}

function writeText(filePath, text) {
  fs.writeFileSync(filePath, text);
}

function chmodExec(filePath) {
  try {
    fs.chmodSync(filePath, 0o755);
  } catch {
    // Best effort
  }
}

function detectVersion() {
  const fromEnv = normalizeVersion(process.env.VERSION);
  if (fromEnv) return fromEnv;

  const checksumsPath = path.join(DIST_DIR, 'checksums.txt');
  const checksums = readTextIfExists(checksumsPath);
  if (checksums) {
    const lines = checksums.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
      const parts = line.split(/\s+/);
      const filename = parts[parts.length - 1] || '';
      const m = filename.match(new RegExp('^' + PROJECT + '_([^_]+)_'));
      if (m && m[1]) return normalizeVersion(m[1]);
    }
  }

  try {
    const tag = cp.execSync('git describe --tags --abbrev=0', {
      cwd: ROOT,
      stdio: ['ignore', 'pipe', 'ignore']
    }).toString().trim();
    if (tag) return normalizeVersion(tag);
  } catch {
    // ignore
  }

  return '';
}

function findBuildDir(goos, goarch) {
  const prefix = DIST_PROJECT + '_' + goos + '_' + goarch;
  const direct = path.join(DIST_DIR, prefix);
  if (fs.existsSync(direct) && fs.statSync(direct).isDirectory()) return direct;

  const entries = fs.readdirSync(DIST_DIR, { withFileTypes: true });
  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    if (entry.name.startsWith(prefix + '_')) {
      return path.join(DIST_DIR, entry.name);
    }
  }
  return '';
}

function findBinary(goos, goarch) {
  const dir = findBuildDir(goos, goarch);
  if (!dir) return '';
  const exeName = goos === 'windows' ? BIN + '.exe' : BIN;
  const candidate = path.join(dir, exeName);
  return fs.existsSync(candidate) ? candidate : '';
}

function platformPackageName(platform, arch) {
  return PROJECT + '-' + platform + '-' + arch;
}

function renderLauncher() {
  // Keep this CommonJS and dependency-free for maximum compatibility.
  return [
    '#!/usr/bin/env node',
    "'use strict';",
    '',
    "const fs = require('fs');",
    "const path = require('path');",
    "const { spawn } = require('child_process');",
    "const cmdName = path.basename(process.argv[1] || '" + BIN + "');",
    '',
    'function pkgFor(platform, arch) {',
    "  if (platform === 'darwin' && arch === 'x64') return '" + platformPackageName('darwin', 'x64') + "';",
    "  if (platform === 'darwin' && arch === 'arm64') return '" + platformPackageName('darwin', 'arm64') + "';",
    "  if (platform === 'linux' && arch === 'x64') return '" + platformPackageName('linux', 'x64') + "';",
    "  if (platform === 'linux' && arch === 'arm64') return '" + platformPackageName('linux', 'arm64') + "';",
    "  if (platform === 'win32' && arch === 'x64') return '" + platformPackageName('win32', 'x64') + "';",
    "  if (platform === 'win32' && arch === 'arm64') return '" + platformPackageName('win32', 'arm64') + "';",
    '  return null;',
    '}',
    '',
    'const platform = process.platform;',
    'const arch = process.arch;',
    'const pkgName = pkgFor(platform, arch);',
    '',
    'if (!pkgName) {',
    "  console.error(cmdName + ': unsupported platform ' + platform + ' ' + arch);",
    '  process.exit(1);',
    '}',
    '',
    'let pkgRoot;',
    'try {',
    "  pkgRoot = path.dirname(require.resolve(pkgName + '/package.json'));",
    '} catch (err) {',
    "  console.error(cmdName + ': platform package missing ' + pkgName);",
    "  console.error('Reinstall with optional dependencies enabled.');",
    "  console.error('For npm you can run npm i --include=optional " + PROJECT + "');",
    '  process.exit(1);',
    '}',
    '',
    "const exe = platform === 'win32' ? '" + BIN + ".exe' : '" + BIN + "';",
    "const binPath = path.join(pkgRoot, 'bin', exe);",
    '',
    'try {',
    "  if (platform !== 'win32') fs.chmodSync(binPath, 0o755);",
    '} catch (err) {',
    '  // Best effort',
    '}',
    '',
    "const child = spawn(binPath, process.argv.slice(2), { stdio: 'inherit' });",
    '',
    "child.on('error', (err) => {",
    "  console.error(cmdName + ': failed to run binary');",
    "  console.error('Path ' + binPath);",
    "  console.error(String(err && err.message ? err.message : err));",
    '  process.exit(1);',
    '});',
    '',
    "child.on('exit', (code, signal) => {",
    '  if (signal) {',
    '    try { process.kill(process.pid, signal); } catch (err) {}',
    '    return;',
    '  }',
    '  process.exit(code == null ? 1 : code);',
    '});',
    ''
  ].join('\n');
}

function build() {
  if (!fs.existsSync(DIST_DIR)) {
    die('dist/ not found. Run GoReleaser first.');
  }

  const version = detectVersion();
  if (!version) {
    die('could not determine version. Set VERSION=1.2.3 or run after GoReleaser so dist/checksums.txt exists.');
  }

  const targets = [
    { npmPlatform: 'darwin', npmArch: 'x64', goos: 'darwin', goarch: 'amd64' },
    { npmPlatform: 'darwin', npmArch: 'arm64', goos: 'darwin', goarch: 'arm64' },
    { npmPlatform: 'linux', npmArch: 'x64', goos: 'linux', goarch: 'amd64' },
    { npmPlatform: 'linux', npmArch: 'arm64', goos: 'linux', goarch: 'arm64' }
  ];

  rmrf(PACKAGES_DIR);
  mkdirp(PACKAGES_DIR);

  const optionalDeps = {};
  for (const t of targets) {
    const pkgName = platformPackageName(t.npmPlatform, t.npmArch);
    optionalDeps[pkgName] = version;
  }

  // Meta package
  const metaDir = path.join(PACKAGES_DIR, PROJECT);
  mkdirp(path.join(metaDir, 'bin'));

  const launcherPath = path.join(metaDir, 'bin', BIN + '.js');
  writeText(launcherPath, renderLauncher());
  chmodExec(launcherPath);

  const rootReadme = path.join(ROOT, 'README.md');
  if (fs.existsSync(rootReadme)) {
    fs.copyFileSync(rootReadme, path.join(metaDir, 'README.md'));
  } else {
    writeText(path.join(metaDir, 'README.md'), '# ' + PROJECT + '\n');
  }

  const agentScriptsSrc = path.join(ROOT, 'scripts', 'agent-state');
  const agentScriptsDst = path.join(metaDir, 'scripts', 'agent-state');
  copyDir(agentScriptsSrc, agentScriptsDst);

  writeJSON(path.join(metaDir, 'package.json'), {
    name: PROJECT,
    version,
    description: 'Tmux layout manager with YAML based configuration.',
    license: 'MIT',
    homepage: REPO_HTTP,
    repository: {
      type: 'git',
      url: REPO_GIT
    },
    bin: {
      [BIN]: 'bin/' + BIN + '.js'
    },
    optionalDependencies: optionalDeps,
    engines: {
      node: '>=18'
    },
    files: [
      'bin/' + BIN + '.js',
      'README.md',
      'scripts/agent-state/'
    ],
    publishConfig: {
      access: 'public'
    }
  });

  // Platform packages
  for (const t of targets) {
    const pkgName = platformPackageName(t.npmPlatform, t.npmArch);
    const binSrc = findBinary(t.goos, t.goarch);
    if (!binSrc) {
      die('missing binary for ' + t.goos + '/' + t.goarch + '. Expected dist/' + DIST_PROJECT + '_' + t.goos + '_' + t.goarch + '/');
    }

    const pkgDir = path.join(PACKAGES_DIR, pkgName);
    const binDir = path.join(pkgDir, 'bin');
    mkdirp(binDir);

    const exeName = t.goos === 'windows' ? BIN + '.exe' : BIN;
    const binDst = path.join(binDir, exeName);
    fs.copyFileSync(binSrc, binDst);
    if (t.goos !== 'windows') chmodExec(binDst);
    const skillsSrc = path.join(ROOT, 'skills');
    const skillsDst = path.join(pkgDir, 'skills');
    copyDir(skillsSrc, skillsDst);

    const os = [t.npmPlatform];
    const cpu = [t.npmArch];

    writeText(path.join(pkgDir, 'README.md'), [
      '# ' + pkgName,
      '',
      'This package contains the ' + BIN + ' binary for ' + t.npmPlatform + ' ' + t.npmArch + '.',
      '',
      'It is installed automatically via optionalDependencies from the main ' + PROJECT + ' package.',
      ''
    ].join('\n'));

    writeJSON(path.join(pkgDir, 'package.json'), {
      name: pkgName,
      version,
      description: 'peky binary for ' + t.npmPlatform + ' ' + t.npmArch + '.',
      license: 'MIT',
      homepage: REPO_HTTP,
      repository: {
        type: 'git',
        url: REPO_GIT
      },
      os,
      cpu,
      files: [
        'bin/' + exeName,
        'README.md',
        'skills/'
      ],
      publishConfig: {
        access: 'public'
      }
    });
  }

  println('Generated npm packages in ' + PACKAGES_DIR);
  println('Version ' + version);
  println('');
  println('Publish order');
  println('  1) publish each platform package');
  println('  2) publish the main ' + PROJECT + ' package');
}

build();
