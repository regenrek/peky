#!/usr/bin/env bash
set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

usage() {
  cat <<'USAGE'
Usage: scripts/perf-profiler [--layout <file>] [--secs <n>] [--fgprof <n>] [--trace <n>] [--block] [--block-rate <duration>] [--mutex] [--mutex-fraction <n>] [--start-delay <n|duration>] [--align-with-send] [--start-on-send] [--trigger-timeout <n|duration>] [--start-timeout <n|duration>] [--gops] [--trace-all] [--paneviews-all] [--no-tmux] [--no-ghostty]

Runs a fresh perf session with the profiler build tag enabled and captures
CPU/heap profiles plus a summary report under .bench.

Options:
  --layout <file>   Layout YAML to run (default: testdata/performance-tests/peakypanes-perf12.yml)
  --secs <n>        CPU profile duration in seconds (default: 30)
  --fgprof <n>      Enable fgprof capture for N seconds (sequential after CPU)
  --trace <n>       Enable runtime trace capture for N seconds (sequential after fgprof)
  --block           Enable block profile capture (written at end)
  --block-rate <d>  Block profile rate (Go duration or ns int, default: 10ms)
  --mutex           Enable mutex profile capture (written at end)
  --mutex-fraction <n> Mutex profile fraction (1/N events, default: 1)
  --start-delay <n> Delay before profiling starts (seconds or Go duration, e.g. 5s)
  --align-with-send Align profile start to 1s before layout send_delay_ms (if present)
  --start-on-send   Wait for the first automation send before starting profiles
  --trigger-timeout Timeout waiting for the first send (seconds or Go duration)
  --start-timeout   Timeout for StartSession RPC (seconds or Go duration)
  --gops            Enable gops agent (config lives under the run output)
  --trace-all       Log all pane view request/response timings (PEAKYPANES_PERF_TRACE_ALL=1)
  --paneviews-all   Render all panes live during profiling (dashboard.performance.render_policy=all)
  --no-tmux         Skip the tmux monitor dashboard (tail + htop)
  --no-ghostty      Run peakypanes in the current terminal (no Ghostty)
  -h, --help        Show this help

Environment:
  PROFILE_SECS      Same as --secs
  PROFILE_DONE      Optional path for a done marker file
  PROFILE_FGPROF    Same as --fgprof (seconds)
  PROFILE_TRACE     Same as --trace (seconds)
  PROFILE_BLOCK_RATE   Same as --block-rate (duration or ns int)
  PROFILE_MUTEX_FRACTION Same as --mutex-fraction
  PROFILE_START_DELAY Same as --start-delay
  PROFILE_ALIGN_SEND  Same as --align-with-send (set to 1)
  PROFILE_START_ON_SEND Same as --start-on-send (set to 1)
  PROFILE_TRIGGER_TIMEOUT Same as --trigger-timeout
  PROFILE_START_TIMEOUT Same as --start-timeout
  PROFILE_GOPS      Same as --gops (set to 1)
  PROFILE_TRACE_ALL Same as --trace-all (set to 1)
  PROFILE_PANEVIEWS_ALL Same as --paneviews-all (set to 1)

Notes:
  - This is dev-only and uses a profiler build tag.
  - The run uses --fresh-config to avoid user config/state.
USAGE
}

layout_file="$ROOT/testdata/performance-tests/peakypanes-perf10-control.yml"
profile_secs="${PROFILE_SECS:-30}"
fgprof_secs="${PROFILE_FGPROF:-}"
trace_secs="${PROFILE_TRACE:-}"
trace_all="${PROFILE_TRACE_ALL:-}"
paneviews_all="${PROFILE_PANEVIEWS_ALL:-}"
block_rate="${PROFILE_BLOCK_RATE:-}"
mutex_fraction="${PROFILE_MUTEX_FRACTION:-}"
start_delay="${PROFILE_START_DELAY:-}"
align_with_send="${PROFILE_ALIGN_SEND:-}"
start_on_send="${PROFILE_START_ON_SEND:-}"
trigger_timeout="${PROFILE_TRIGGER_TIMEOUT:-}"
start_timeout="${PROFILE_START_TIMEOUT:-}"
enable_gops=false
use_tmux=true
use_ghostty=true
enable_block=false
enable_mutex=false

if [[ -n "$block_rate" ]]; then
  enable_block=true
fi
if [[ -n "$mutex_fraction" ]]; then
  enable_mutex=true
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --layout)
      shift
      layout_file="${1:-}"
      if [[ -z "$layout_file" ]]; then
        echo "perf-profiler: --layout requires a file" >&2
        exit 1
      fi
      shift
      ;;
    --secs)
      shift
      profile_secs="${1:-}"
      if [[ -z "$profile_secs" ]]; then
        echo "perf-profiler: --secs requires a number" >&2
        exit 1
      fi
      shift
      ;;
    --no-tmux)
      use_tmux=false
      shift
      ;;
    --fgprof)
      shift
      fgprof_secs="${1:-}"
      if [[ -z "$fgprof_secs" ]]; then
        echo "perf-profiler: --fgprof requires a number" >&2
        exit 1
      fi
      shift
      ;;
    --trace)
      shift
      trace_secs="${1:-}"
      if [[ -z "$trace_secs" ]]; then
        echo "perf-profiler: --trace requires a number" >&2
        exit 1
      fi
      shift
      ;;
    --block)
      enable_block=true
      shift
      ;;
    --block-rate)
      shift
      block_rate="${1:-}"
      if [[ -z "$block_rate" ]]; then
        echo "perf-profiler: --block-rate requires a value" >&2
        exit 1
      fi
      enable_block=true
      shift
      ;;
    --mutex)
      enable_mutex=true
      shift
      ;;
    --mutex-fraction)
      shift
      mutex_fraction="${1:-}"
      if [[ -z "$mutex_fraction" ]]; then
        echo "perf-profiler: --mutex-fraction requires a value" >&2
        exit 1
      fi
      enable_mutex=true
      shift
      ;;
    --start-delay)
      shift
      start_delay="${1:-}"
      if [[ -z "$start_delay" ]]; then
        echo "perf-profiler: --start-delay requires a value" >&2
        exit 1
      fi
      shift
      ;;
    --start-timeout)
      shift
      start_timeout="${1:-}"
      if [[ -z "$start_timeout" ]]; then
        echo "perf-profiler: --start-timeout requires a value" >&2
        exit 1
      fi
      shift
      ;;
    --align-with-send)
      align_with_send=1
      shift
      ;;
    --start-on-send)
      start_on_send=1
      shift
      ;;
    --trigger-timeout)
      shift
      trigger_timeout="${1:-}"
      if [[ -z "$trigger_timeout" ]]; then
        echo "perf-profiler: --trigger-timeout requires a value" >&2
        exit 1
      fi
      shift
      ;;
    --gops)
      enable_gops=true
      shift
      ;;
    --trace-all)
      trace_all=1
      shift
      ;;
    --paneviews-all)
      paneviews_all=1
      shift
      ;;
    --no-ghostty)
      use_ghostty=false
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "perf-profiler: unknown flag $1" >&2
      exit 1
      ;;
  esac
done

if [[ ! -f "$layout_file" ]]; then
  echo "perf-profiler: layout file not found: $layout_file" >&2
  exit 1
fi
if ! [[ "$profile_secs" =~ ^[0-9]+$ ]]; then
  echo "perf-profiler: --secs must be an integer" >&2
  exit 1
fi
if [[ "$profile_secs" -lt 1 ]]; then
  echo "perf-profiler: --secs must be >= 1" >&2
  exit 1
fi
if [[ -n "$fgprof_secs" && ! "$fgprof_secs" =~ ^[0-9]+$ ]]; then
  echo "perf-profiler: --fgprof must be an integer" >&2
  exit 1
fi
if [[ -n "$fgprof_secs" && "$fgprof_secs" -lt 1 ]]; then
  echo "perf-profiler: --fgprof must be >= 1" >&2
  exit 1
fi
if [[ -n "$trace_secs" && ! "$trace_secs" =~ ^[0-9]+$ ]]; then
  echo "perf-profiler: --trace must be an integer" >&2
  exit 1
fi
if [[ -n "$trace_secs" && "$trace_secs" -lt 1 ]]; then
  echo "perf-profiler: --trace must be >= 1" >&2
  exit 1
fi
if [[ -n "$block_rate" && ! "$block_rate" =~ ^[0-9]+(ns|us|ms|s|m|h)?$ ]]; then
  echo "perf-profiler: --block-rate must be a duration (e.g. 10ms) or ns integer" >&2
  exit 1
fi
if [[ -n "$mutex_fraction" && ! "$mutex_fraction" =~ ^[0-9]+$ ]]; then
  echo "perf-profiler: --mutex-fraction must be an integer" >&2
  exit 1
fi
if [[ -n "$mutex_fraction" && "$mutex_fraction" -lt 1 ]]; then
  echo "perf-profiler: --mutex-fraction must be >= 1" >&2
  exit 1
fi
if [[ -n "$start_delay" && ! "$start_delay" =~ ^[0-9]+([smh]|ms)?$ ]]; then
  echo "perf-profiler: --start-delay must be seconds or duration (e.g. 5 or 5s)" >&2
  exit 1
fi
if [[ -n "$trigger_timeout" && ! "$trigger_timeout" =~ ^[0-9]+([smh]|ms)?$ ]]; then
  echo "perf-profiler: --trigger-timeout must be seconds or duration (e.g. 30 or 30s)" >&2
  exit 1
fi
if [[ -n "$start_timeout" && ! "$start_timeout" =~ ^[0-9]+([smh]|ms)?$ ]]; then
  echo "perf-profiler: --start-timeout must be seconds or duration (e.g. 30 or 30s)" >&2
  exit 1
fi

if [[ -n "$start_on_send" && -n "$align_with_send" ]]; then
  echo "perf-profiler: --align-with-send ignored because --start-on-send is set" >&2
  align_with_send=""
fi

if [[ -z "$start_delay" && -n "$align_with_send" ]]; then
  send_delay_ms=""
  if [[ -f "$layout_file" ]]; then
    send_delay_ms="$(awk -F: '/send_delay_ms/ {gsub(/[^0-9]/, "", $2); if ($2 != "") {print $2; exit}}' "$layout_file")"
  fi
  if [[ -n "$send_delay_ms" ]]; then
    send_delay_sec=$((send_delay_ms / 1000))
    if [[ "$send_delay_sec" -gt 1 ]]; then
      start_delay=$((send_delay_sec - 1))
    else
      start_delay=0
    fi
  fi
fi
if [[ -n "$start_on_send" && -z "$trigger_timeout" ]]; then
  trigger_timeout="60s"
fi

if [[ "$enable_block" == true && -z "$block_rate" ]]; then
  block_rate="10ms"
fi
if [[ "$enable_mutex" == true && -z "$mutex_fraction" ]]; then
  mutex_fraction="1"
fi

stamp="$(date +%Y%m%d-%H%M%S)"
out_root="$ROOT/.bench/profiler-12/$stamp"
run_dir="$out_root/run"
tmp_root="/tmp/peakypanes-prof-$stamp"
runtime_dir="$tmp_root/runtime"
config_dir="$run_dir/config"
pid_file="$runtime_dir/daemon.pid"
mkdir -p "$run_dir" "$runtime_dir" "$config_dir/layouts"
chmod 700 "$runtime_dir"

cp "$layout_file" "$run_dir/.peakypanes.yml"

bin_path="$out_root/peakypanes-profiler"
(
  cd "$ROOT"
  go build -tags profiler -o "$bin_path" ./cmd/peakypanes
)

export PEAKYPANES_CPU_PROFILE="$out_root/cpu.pprof"
export PEAKYPANES_MEM_PROFILE="$out_root/heap.pprof"
export PEAKYPANES_CPU_PROFILE_SECS="$profile_secs"
export PEAKYPANES_LOG_FILE="$out_root/daemon.log"
export PEAKYPANES_LOG_LEVEL="debug"
export PEAKYPANES_PROFILE_DONE="$out_root/DONE"
export PEAKYPANES_PERF_DEBUG="1"
export PEAKYPANES_RUNTIME_DIR="$runtime_dir"
export PEAKYPANES_CONFIG_DIR="$config_dir"
export PEAKYPANES_FRESH_CONFIG="1"
export PEAKYPANES_DAEMON_PID="$pid_file"
if [[ "$enable_block" == true ]]; then
  export PEAKYPANES_BLOCK_PROFILE="$out_root/block.pprof"
  if [[ -n "$block_rate" ]]; then
    export PEAKYPANES_BLOCK_RATE="$block_rate"
  fi
fi
if [[ "$enable_mutex" == true ]]; then
  export PEAKYPANES_MUTEX_PROFILE="$out_root/mutex.pprof"
  if [[ -n "$mutex_fraction" ]]; then
    export PEAKYPANES_MUTEX_FRACTION="$mutex_fraction"
  fi
fi
if [[ -n "$start_delay" ]]; then
  export PEAKYPANES_PROFILE_START_DELAY="$start_delay"
fi
if [[ -n "$start_on_send" ]]; then
  export PEAKYPANES_PROFILE_START_ON_SEND="1"
fi
if [[ -n "$trigger_timeout" ]]; then
  export PEAKYPANES_PROFILE_TRIGGER_TIMEOUT="$trigger_timeout"
fi
if [[ -n "$fgprof_secs" ]]; then
  export PEAKYPANES_FGPROF="$out_root/fgprof.pprof"
  export PEAKYPANES_FGPROF_SECS="$fgprof_secs"
fi
if [[ -n "$trace_secs" ]]; then
  export PEAKYPANES_TRACE="$out_root/trace.out"
  export PEAKYPANES_TRACE_SECS="$trace_secs"
fi
if [[ -n "$trace_all" ]]; then
  export PEAKYPANES_PERF_TRACE_ALL="1"
fi
if [[ -n "$start_timeout" ]]; then
  export PEAKYPANES_START_TIMEOUT="$start_timeout"
fi
if [[ "$enable_gops" == true ]]; then
  gops_dir="$out_root/gops"
  mkdir -p "$gops_dir"
  export PEAKYPANES_GOPS=1
  export PEAKYPANES_GOPS_CONFIG_DIR="$gops_dir"
fi

report="$out_root/report.txt"
run_log="$out_root/run.log"
daemon_log="$out_root/daemon.log"
done_marker="$out_root/DONE"
rm -f "$done_marker"
touch "$run_log" "$daemon_log"

config_file="$config_dir/config.yml"
if [[ -n "$paneviews_all" ]]; then
  cat >"$config_file" <<'EOF'
dashboard:
  performance:
    render_policy: all
EOF
fi

{
  echo "# peakypanes perf profiler"
  echo "date: $stamp"
  echo "layout: $layout_file"
  echo "profile_secs: $profile_secs"
  echo "perf_debug: enabled"
  if [[ -n "$start_delay" ]]; then
    echo "profile_start_delay: $start_delay"
  fi
  if [[ -n "$start_on_send" ]]; then
    echo "profile_start_on_send: true"
  fi
  if [[ -n "$trigger_timeout" ]]; then
    echo "profile_trigger_timeout: $trigger_timeout"
  fi
  if [[ -n "$start_timeout" ]]; then
    echo "start_timeout: $start_timeout"
  fi
  if [[ -n "$fgprof_secs" ]]; then
    echo "fgprof_secs: $fgprof_secs"
    echo "fgprof: $out_root/fgprof.pprof"
  fi
  if [[ -n "$trace_secs" ]]; then
    echo "trace_secs: $trace_secs"
    echo "trace: $out_root/trace.out"
  fi
  if [[ -n "$trace_all" ]]; then
    echo "trace_all: enabled"
  fi
  if [[ -n "$paneviews_all" ]]; then
    echo "render_policy: all"
  fi
  if [[ "$enable_block" == true ]]; then
    echo "block_profile: $out_root/block.pprof"
    if [[ -n "$block_rate" ]]; then
      echo "block_rate: $block_rate"
    fi
  fi
  if [[ "$enable_mutex" == true ]]; then
    echo "mutex_profile: $out_root/mutex.pprof"
    if [[ -n "$mutex_fraction" ]]; then
      echo "mutex_fraction: $mutex_fraction"
    fi
  fi
  if [[ "$enable_gops" == true ]]; then
    echo "gops: enabled"
    echo "gops_config: $out_root/gops"
  fi
  echo "go: $(go version)"
  echo "bin: $bin_path"
  echo "out: $out_root"
  echo "runtime_dir: $runtime_dir"
  echo "config_dir: $config_dir"
  echo "done: $done_marker"
  echo
} > "$report"

monitor_session=""
if [[ "$use_tmux" == true && -z "${TMUX:-}" ]]; then
  if command -v tmux >/dev/null 2>&1; then
    monitor_session="perf-profiler-$stamp"
    monitor_cmd="set +euo pipefail; tail -n 200 -f $(printf %q "$daemon_log") & while [[ ! -f $(printf %q "$done_marker") ]]; do sleep 1; done; echo \"===== PROFILER DONE =====\"; wait"
    tmux new-session -d -s "$monitor_session" -c "$ROOT" "$monitor_cmd"
    left_pane="$(tmux display-message -p -t "$monitor_session:" "#{pane_id}")"
    pane_cmd="htop"
    if command -v htop >/dev/null 2>&1; then
      pane_cmd="htop -F peakypanes,claude"
    else
      pane_cmd="top"
    fi
    tmux split-window -h -t "$left_pane" -c "$ROOT" "$pane_cmd"
    window_id="$(tmux display-message -p -t "$monitor_session:" "#{window_id}")"
    tmux select-layout -t "$window_id" even-horizontal
    tmux set-option -t "$monitor_session" remain-on-exit on >/dev/null 2>&1 || true
  fi
fi

run_cmd=""
start_wrapper="$out_root/start.sh"
cat <<EOF > "$start_wrapper"
#!/usr/bin/env bash
set -euo pipefail

attempt=0
max="\${PEAKYPANES_START_RETRIES:-5}"
if [[ "\$max" -lt 1 ]]; then
  max=1
fi

while true; do
  $(printf %q "$bin_path") start --fresh-config --yes --path $(printf %q "$run_dir")
  code=\$?
  if [[ "\$code" -eq 0 ]]; then
    exit 0
  fi
  attempt=\$((attempt + 1))
  if [[ "\$attempt" -ge "\$max" ]]; then
    echo "peakypanes: start failed after \$attempt attempts (exit \$code)" >&2
    exit "\$code"
  fi
  echo "peakypanes: start failed (exit \$code), retrying..." >&2
  sleep 1
done
EOF
chmod +x "$start_wrapper"

cleanup_after_done() {
  if [[ ! -f "$done_marker" ]]; then
    return
  fi
  if [[ -f "$pid_file" ]]; then
    pid="$(cat "$pid_file" 2>/dev/null || true)"
    if [[ "$pid" =~ ^[0-9]+$ ]]; then
      kill "$pid" >/dev/null 2>&1 || true
    fi
  fi
  pkill -f "$bin_path daemon" >/dev/null 2>&1 || true
  pkill -f "$start_wrapper" >/dev/null 2>&1 || true
  pkill -f "$bin_path start --fresh-config --path $run_dir" >/dev/null 2>&1 || true
  if [[ -n "$monitor_session" ]]; then
    tmux kill-session -t "$monitor_session" >/dev/null 2>&1 || true
  fi
  if [[ -n "$tmp_root" ]]; then
    rm -rf "$tmp_root" >/dev/null 2>&1 || true
  fi
}

(
  while [[ ! -f "$done_marker" ]]; do
    sleep 1
  done
  cleanup_after_done
) &

if command -v script >/dev/null 2>&1; then
  run_cmd="script -q $(printf %q "$run_log") $(printf %q "$start_wrapper")"
else
  run_cmd="$(printf %q "$start_wrapper")"
fi

if [[ "$use_ghostty" == true ]]; then
  if [[ "$(uname -s)" == "Darwin" && -d "/Applications/Ghostty.app" ]]; then
    env_exports=$(printf 'export PEAKYPANES_CPU_PROFILE=%q; export PEAKYPANES_MEM_PROFILE=%q; export PEAKYPANES_CPU_PROFILE_SECS=%q; export PEAKYPANES_LOG_FILE=%q; export PEAKYPANES_LOG_LEVEL=%q; export PEAKYPANES_PROFILE_DONE=%q; export PEAKYPANES_PERF_DEBUG=%q; ' "$PEAKYPANES_CPU_PROFILE" "$PEAKYPANES_MEM_PROFILE" "$PEAKYPANES_CPU_PROFILE_SECS" "$PEAKYPANES_LOG_FILE" "$PEAKYPANES_LOG_LEVEL" "$PEAKYPANES_PROFILE_DONE" "$PEAKYPANES_PERF_DEBUG")
    if [[ -n "$trace_all" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_PERF_TRACE_ALL=%q; ' "1")
    fi
    env_exports+=$(printf 'export PEAKYPANES_RUNTIME_DIR=%q; export PEAKYPANES_CONFIG_DIR=%q; export PEAKYPANES_FRESH_CONFIG=%q; export PEAKYPANES_DAEMON_PID=%q; ' "$PEAKYPANES_RUNTIME_DIR" "$PEAKYPANES_CONFIG_DIR" "$PEAKYPANES_FRESH_CONFIG" "$PEAKYPANES_DAEMON_PID")
    if [[ -n "$start_delay" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_PROFILE_START_DELAY=%q; ' "$start_delay")
    fi
    if [[ -n "$start_on_send" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_PROFILE_START_ON_SEND=%q; ' "1")
    fi
    if [[ -n "$trigger_timeout" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_PROFILE_TRIGGER_TIMEOUT=%q; ' "$trigger_timeout")
    fi
    if [[ -n "$start_timeout" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_START_TIMEOUT=%q; ' "$start_timeout")
    fi
    if [[ -n "$fgprof_secs" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_FGPROF=%q; export PEAKYPANES_FGPROF_SECS=%q; ' "$PEAKYPANES_FGPROF" "$PEAKYPANES_FGPROF_SECS")
    fi
    if [[ -n "$trace_secs" ]]; then
      env_exports+=$(printf 'export PEAKYPANES_TRACE=%q; export PEAKYPANES_TRACE_SECS=%q; ' "$PEAKYPANES_TRACE" "$PEAKYPANES_TRACE_SECS")
    fi
    if [[ "$enable_block" == true ]]; then
      env_exports+=$(printf 'export PEAKYPANES_BLOCK_PROFILE=%q; ' "$PEAKYPANES_BLOCK_PROFILE")
      if [[ -n "$block_rate" ]]; then
        env_exports+=$(printf 'export PEAKYPANES_BLOCK_RATE=%q; ' "$PEAKYPANES_BLOCK_RATE")
      fi
    fi
    if [[ "$enable_mutex" == true ]]; then
      env_exports+=$(printf 'export PEAKYPANES_MUTEX_PROFILE=%q; ' "$PEAKYPANES_MUTEX_PROFILE")
      if [[ -n "$mutex_fraction" ]]; then
        env_exports+=$(printf 'export PEAKYPANES_MUTEX_FRACTION=%q; ' "$PEAKYPANES_MUTEX_FRACTION")
      fi
    fi
    if [[ "$enable_gops" == true ]]; then
      env_exports+=$(printf 'export PEAKYPANES_GOPS=%q; export PEAKYPANES_GOPS_CONFIG_DIR=%q; ' "$PEAKYPANES_GOPS" "$PEAKYPANES_GOPS_CONFIG_DIR")
    fi
    cmd=$(printf 'set -euo pipefail; %s cd %q; %s' "$env_exports" "$ROOT" "$run_cmd")
    open -na Ghostty.app --args -e /bin/bash -lc "$cmd"
  else
    echo "perf-profiler: Ghostty not available; running in current terminal." >&2
    use_ghostty=false
  fi
fi

if [[ "$use_ghostty" == false ]]; then
  echo "Profiler output: $out_root"
  echo "Run log: $run_log"
  echo "perf_debug: enabled"
  echo "Daemon log: $daemon_log"
  if [[ -n "$start_delay" ]]; then
    echo "profile_start_delay: $start_delay"
  fi
  if [[ -n "$start_on_send" ]]; then
    echo "profile_start_on_send: true"
  fi
  if [[ -n "$trigger_timeout" ]]; then
    echo "profile_trigger_timeout: $trigger_timeout"
  fi
  if [[ -n "$start_timeout" ]]; then
    echo "start_timeout: $start_timeout"
  fi
  if [[ -n "$fgprof_secs" ]]; then
    echo "fgprof: $out_root/fgprof.pprof"
  fi
  if [[ -n "$trace_secs" ]]; then
    echo "trace: $out_root/trace.out"
  fi
  if [[ -n "$trace_all" ]]; then
    echo "trace_all: enabled"
  fi
  if [[ "$enable_block" == true ]]; then
    echo "block: $out_root/block.pprof"
  fi
  if [[ "$enable_mutex" == true ]]; then
    echo "mutex: $out_root/mutex.pprof"
  fi
  if [[ "$enable_gops" == true ]]; then
    echo "gops config: $out_root/gops"
  fi
  echo "Done marker: $done_marker"
  echo
  set +e
  eval "$run_cmd"
  run_code=$?
  set -e
  if [[ "$run_code" -ne 0 && ! -f "$done_marker" ]]; then
    exit "$run_code"
  fi
fi

if [[ -n "$monitor_session" ]]; then
  tmux attach -t "$monitor_session"
fi

if [[ -f "$out_root/cpu.pprof" ]]; then
  go tool pprof -top -nodecount=30 "$bin_path" "$out_root/cpu.pprof" > "$out_root/cpu.top.txt" || true
fi
if [[ -f "$out_root/heap.pprof" ]]; then
  go tool pprof -top -nodecount=30 "$bin_path" "$out_root/heap.pprof" > "$out_root/heap.top.txt" || true
fi
if [[ -f "$out_root/block.pprof" ]]; then
  go tool pprof -top -nodecount=30 "$bin_path" "$out_root/block.pprof" > "$out_root/block.top.txt" || true
fi
if [[ -f "$out_root/mutex.pprof" ]]; then
  go tool pprof -top -nodecount=30 "$bin_path" "$out_root/mutex.pprof" > "$out_root/mutex.top.txt" || true
fi

timings_out="$out_root/timings.tsv"
timings_summary="$out_root/timings.summary.txt"
if [[ -f "$daemon_log" ]]; then
  if ! command -v jq >/dev/null 2>&1; then
    echo "perf-profiler: jq not found; skipping timings table generation" >&2
  else
    jq -n -r '
      def dur_ms:
        if . == null or . == "-" or . == "n/a" then null
        # Go time.Duration encodes as int64 nanoseconds when emitted as a JSON number.
        elif type == "number" then (. / 1000000)
        elif type != "string" then null
        elif test("µs$") then (sub("µs$";"") | tonumber / 1000)
        elif test("us$") then (sub("us$";"") | tonumber / 1000)
        elif test("ms$") then (sub("ms$";"") | tonumber)
        elif test("s$") then (sub("s$";"") | tonumber * 1000)
        else (tonumber? )
        end;

      def lpad($width; $ch):
        tostring as $s
        | if ($s | length) >= $width then $s
          else (($ch * ($width - ($s | length))) + $s)
          end;

      def dash: "-";
      def val($o; $k): ($o[$k] // dash);
      def ms($o; $k): (val($o; $k) | dur_ms | if . == null then dash else tostring end);

      (reduce inputs as $e ({}; 
        if ($e|type) != "object" then .
        elif ($e.pane_id? // null) == null then .
        else
          .[$e.pane_id] = (
            (.[$e.pane_id] // {}) as $cur
            | if $e.msg == "native: pane pty ready" then ($cur + {pty_ready: ($e.since_start // dash)})
              elif $e.msg == "native: pane process started" then ($cur + {process_started: ($e.since_start // dash)})
              elif $e.msg == "native: pane io started" then ($cur + {io_started: ($e.since_start // dash)})
              elif $e.msg == "native: pane first update" then ($cur + {first_update: ($e.since_start // dash)})
              elif $e.msg == "native: pane first output" then ($cur + {first_output: ($e.since_start // dash)})
              elif $e.msg == "native: pane first input sent" then ($cur + {first_input: ($e.since_start // dash)})
              elif $e.msg == "native: pane first output after pty ready" then ($cur + {first_output_after_pty: ($e.since_pty_ready // dash)})
              elif $e.msg == "native: pane first output after input" then ($cur + {first_output_after_input: ($e.since_start // dash), since_input: ($e.since_input // dash)})
              elif $e.msg == "sessiond: pane view first request" then ($cur + {first_view_request: ($e.since_start // dash)})
              elif $e.msg == "sessiond: pane view first render after output" then ($cur + {
                first_render_after_output: ($e.since_start // dash),
                output_to_view_req: ($e.output_to_view_req // dash),
                view_req_to_render: ($e.view_req_to_render // dash),
                output_to_render: ($e.output_to_render // dash),
                queue_wait: ($e.queue_wait // dash),
                compute: ($e.compute // dash)
              })
              else $cur
              end
          )
        end
      )) as $m
      | [
          "pane_num","pane","pty_ready","process_started","io_started","first_update","first_output","first_input",
          "first_output_after_input","since_input","first_output_after_pty","first_view_request","first_render_after_output",
          "output_to_view_req","view_req_to_render","output_to_render","queue_wait","compute",
          "pty_ready_ms","process_started_ms","io_started_ms","first_update_ms","first_output_ms","first_input_ms",
          "first_output_after_input_ms","since_input_ms","first_output_after_pty_ms","first_view_request_ms",
          "first_render_after_output_ms","output_to_view_req_ms","view_req_to_render_ms","output_to_render_ms",
          "queue_wait_ms","compute_ms"
        ] | @tsv,
        (
          ($m | keys) 
          | sort_by(sub("^p-";"") | tonumber? // 0)
          | .[]
          | . as $pane
          | ($m[$pane] // {}) as $row
          | [
              (sub("^p-";"") | tonumber? // 0 | lpad(3;"0")),
              $pane,
              val($row;"pty_ready"),
              val($row;"process_started"),
              val($row;"io_started"),
              val($row;"first_update"),
              val($row;"first_output"),
              val($row;"first_input"),
              val($row;"first_output_after_input"),
              val($row;"since_input"),
              val($row;"first_output_after_pty"),
              val($row;"first_view_request"),
              val($row;"first_render_after_output"),
              val($row;"output_to_view_req"),
              val($row;"view_req_to_render"),
              val($row;"output_to_render"),
              val($row;"queue_wait"),
              val($row;"compute"),
              ms($row;"pty_ready"),
              ms($row;"process_started"),
              ms($row;"io_started"),
              ms($row;"first_update"),
              ms($row;"first_output"),
              ms($row;"first_input"),
              ms($row;"first_output_after_input"),
              ms($row;"since_input"),
              ms($row;"first_output_after_pty"),
              ms($row;"first_view_request"),
              ms($row;"first_render_after_output"),
              ms($row;"output_to_view_req"),
              ms($row;"view_req_to_render"),
              ms($row;"output_to_render"),
              ms($row;"queue_wait"),
              ms($row;"compute")
            ] | @tsv
        )
    ' "$daemon_log" | sort -n > "$timings_out"
  fi

  awk -F '\t' '
  function upd(val, minv, maxv, sumv, cntv) {
    if (val == "" || val == "-") { return minv "\t" maxv "\t" sumv "\t" cntv }
    v = val + 0
    if (cntv == 0 || v < minv) { minv = v }
    if (cntv == 0 || v > maxv) { maxv = v }
    sumv += v
    cntv += 1
    return minv "\t" maxv "\t" sumv "\t" cntv
  }
  NR == 1 { next }
  {
    split(upd($19, min_pr, max_pr, sum_pr, cnt_pr), a, "\t"); min_pr=a[1]; max_pr=a[2]; sum_pr=a[3]; cnt_pr=a[4]
    split(upd($20, min_ps, max_ps, sum_ps, cnt_ps), a, "\t"); min_ps=a[1]; max_ps=a[2]; sum_ps=a[3]; cnt_ps=a[4]
    split(upd($21, min_io, max_io, sum_io, cnt_io), a, "\t"); min_io=a[1]; max_io=a[2]; sum_io=a[3]; cnt_io=a[4]
    split(upd($22, min_fu, max_fu, sum_fu, cnt_fu), a, "\t"); min_fu=a[1]; max_fu=a[2]; sum_fu=a[3]; cnt_fu=a[4]
    split(upd($23, min_out, max_out, sum_out, cnt_out), a, "\t"); min_out=a[1]; max_out=a[2]; sum_out=a[3]; cnt_out=a[4]
    split(upd($24, min_in, max_in, sum_in, cnt_in), a, "\t"); min_in=a[1]; max_in=a[2]; sum_in=a[3]; cnt_in=a[4]
    split(upd($25, min_oa, max_oa, sum_oa, cnt_oa), a, "\t"); min_oa=a[1]; max_oa=a[2]; sum_oa=a[3]; cnt_oa=a[4]
    split(upd($26, min_si, max_si, sum_si, cnt_si), a, "\t"); min_si=a[1]; max_si=a[2]; sum_si=a[3]; cnt_si=a[4]
    split(upd($27, min_op, max_op, sum_op, cnt_op), a, "\t"); min_op=a[1]; max_op=a[2]; sum_op=a[3]; cnt_op=a[4]
    split(upd($28, min_vr, max_vr, sum_vr, cnt_vr), a, "\t"); min_vr=a[1]; max_vr=a[2]; sum_vr=a[3]; cnt_vr=a[4]
    split(upd($29, min_fr, max_fr, sum_fr, cnt_fr), a, "\t"); min_fr=a[1]; max_fr=a[2]; sum_fr=a[3]; cnt_fr=a[4]
    split(upd($30, min_otr, max_otr, sum_otr, cnt_otr), a, "\t"); min_otr=a[1]; max_otr=a[2]; sum_otr=a[3]; cnt_otr=a[4]
    split(upd($31, min_rtr, max_rtr, sum_rtr, cnt_rtr), a, "\t"); min_rtr=a[1]; max_rtr=a[2]; sum_rtr=a[3]; cnt_rtr=a[4]
    split(upd($32, min_otrr, max_otrr, sum_otrr, cnt_otrr), a, "\t"); min_otrr=a[1]; max_otrr=a[2]; sum_otrr=a[3]; cnt_otrr=a[4]
    split(upd($33, min_qw, max_qw, sum_qw, cnt_qw), a, "\t"); min_qw=a[1]; max_qw=a[2]; sum_qw=a[3]; cnt_qw=a[4]
    split(upd($34, min_comp, max_comp, sum_comp, cnt_comp), a, "\t"); min_comp=a[1]; max_comp=a[2]; sum_comp=a[3]; cnt_comp=a[4]
  }
  END {
    print "timings_summary_ms:"
    if (cnt_pr > 0) { printf "  pty_ready: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_pr, min_pr, max_pr, sum_pr/cnt_pr } else { print "  pty_ready: no data" }
    if (cnt_ps > 0) { printf "  process_started: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_ps, min_ps, max_ps, sum_ps/cnt_ps } else { print "  process_started: no data" }
    if (cnt_io > 0) { printf "  io_started: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_io, min_io, max_io, sum_io/cnt_io } else { print "  io_started: no data" }
    if (cnt_fu > 0) { printf "  first_update: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_fu, min_fu, max_fu, sum_fu/cnt_fu } else { print "  first_update: no data" }
    if (cnt_out > 0) { printf "  first_output: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_out, min_out, max_out, sum_out/cnt_out } else { print "  first_output: no data" }
    if (cnt_in > 0) { printf "  first_input: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_in, min_in, max_in, sum_in/cnt_in } else { print "  first_input: no data" }
    if (cnt_oa > 0) { printf "  first_output_after_input: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_oa, min_oa, max_oa, sum_oa/cnt_oa } else { print "  first_output_after_input: no data" }
    if (cnt_si > 0) { printf "  since_input: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_si, min_si, max_si, sum_si/cnt_si } else { print "  since_input: no data" }
    if (cnt_op > 0) { printf "  first_output_after_pty: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_op, min_op, max_op, sum_op/cnt_op } else { print "  first_output_after_pty: no data" }
    if (cnt_vr > 0) { printf "  first_view_request: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_vr, min_vr, max_vr, sum_vr/cnt_vr } else { print "  first_view_request: no data" }
    if (cnt_fr > 0) { printf "  first_render_after_output: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_fr, min_fr, max_fr, sum_fr/cnt_fr } else { print "  first_render_after_output: no data" }
    if (cnt_otr > 0) { printf "  output_to_view_req: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_otr, min_otr, max_otr, sum_otr/cnt_otr } else { print "  output_to_view_req: no data" }
    if (cnt_rtr > 0) { printf "  view_req_to_render: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_rtr, min_rtr, max_rtr, sum_rtr/cnt_rtr } else { print "  view_req_to_render: no data" }
    if (cnt_otrr > 0) { printf "  output_to_render: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_otrr, min_otrr, max_otrr, sum_otrr/cnt_otrr } else { print "  output_to_render: no data" }
    if (cnt_qw > 0) { printf "  queue_wait: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_qw, min_qw, max_qw, sum_qw/cnt_qw } else { print "  queue_wait: no data" }
    if (cnt_comp > 0) { printf "  compute: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_comp, min_comp, max_comp, sum_comp/cnt_comp } else { print "  compute: no data" }
  }' "$timings_out" > "$timings_summary"

  {
    echo
    echo "timings_table: $timings_out"
    echo "timings_summary: $timings_summary"
    echo
    cat "$timings_summary"
  } >> "$report"

  input_output_out="$out_root/timings.input_output.txt"
  awk -F '\t' '
  function upd(val, minv, maxv, sumv, cntv) {
    if (val == "" || val == "-") { return minv "\t" maxv "\t" sumv "\t" cntv }
    v = val + 0
    if (cntv == 0 || v < minv) { minv = v }
    if (cntv == 0 || v > maxv) { maxv = v }
    sumv += v
    cntv += 1
    return minv "\t" maxv "\t" sumv "\t" cntv
  }
  NR == 1 { next }
  {
    split(upd($25, min_foai, max_foai, sum_foai, cnt_foai), a, "\t"); min_foai=a[1]; max_foai=a[2]; sum_foai=a[3]; cnt_foai=a[4]
    split(upd($26, min_si, max_si, sum_si, cnt_si), a, "\t"); min_si=a[1]; max_si=a[2]; sum_si=a[3]; cnt_si=a[4]
  }
  END {
    print "input_to_output_ms:"
    if (cnt_foai > 0) { printf "  first_output_after_input: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_foai, min_foai, max_foai, sum_foai/cnt_foai } else { print "  first_output_after_input: no data" }
    if (cnt_si > 0) { printf "  since_input: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_si, min_si, max_si, sum_si/cnt_si } else { print "  since_input: no data" }
  }' "$timings_out" > "$input_output_out"

  coverage_out="$out_root/timings.coverage.txt"
  expected_panes=""
  if command -v jq >/dev/null 2>&1; then
    expected_panes="$(jq -r 'select(.msg == "native: session started") | .panes // empty' "$daemon_log" | head -n 1)"
  fi
  awk -F '\t' -v expected="$expected_panes" '
  NR == 1 { next }
  {
    seen++
    pane=$2
    if ($7 != "-" ) out++
    if ($8 != "-" ) ins++
    if ($12 != "-" ) viewreq++
    if ($13 != "-" ) render++
    if ($12 == "-" ) missing_req = (missing_req == "" ? pane : missing_req "," pane)
    if ($13 == "-" ) missing_render = (missing_render == "" ? pane : missing_render "," pane)
  }
  END {
    print "timings_coverage:"
    if (expected != "") { printf "  panes_expected: %s\n", expected }
    printf "  panes_seen: %d\n", seen
    printf "  first_output: %d\n", out
    printf "  first_input: %d\n", ins
    printf "  first_view_request: %d\n", viewreq
    printf "  first_render_after_output: %d\n", render
    if (missing_req != "") { printf "  missing_first_view_request: %s\n", missing_req }
    if (missing_render != "") { printf "  missing_first_render_after_output: %s\n", missing_render }
  }' "$timings_out" > "$coverage_out"

  top_slow="$out_root/timings.top_slow.tsv"
  { head -n 1 "$timings_out"; tail -n +2 "$timings_out" | sort -t $'\t' -k27,27nr | head -n 5; } > "$top_slow"

  tui_skips="$out_root/timings.tui_skips.txt"
  if [[ -f "$run_log" ]]; then
    LC_ALL=C awk '
    function strip_esc(s) {
      gsub(/\x1b\[[0-9;]*[A-Za-z]/, "", s)
      return s
    }
    {
      line = strip_esc($0)
      if (line ~ /tui: pane view skip/) {
        pane="-"
        reason=""
        for (i=1;i<=NF;i++) {
          if ($i ~ /^pane=/) { pane=substr($i,6) }
          if ($i ~ /^reason=/) { reason=substr($i,8) }
        }
        if (reason != "") {
          counts[reason]++
          if (pane != "-" && pane != "") { rp[reason, pane]=1 }
        }
      }
    }
    END {
      print "tui_skip_reasons:"
      for (r in counts) {
        panes=""
        for (k in rp) {
          split(k, parts, SUBSEP)
          if (parts[1] == r) {
            panes = (panes == "" ? parts[2] : panes "," parts[2])
          }
        }
        if (panes != "") {
          printf "  %s: count=%d panes=%s\n", r, counts[r], panes
        } else {
          printf "  %s: count=%d\n", r, counts[r]
        }
      }
    }' "$run_log" > "$tui_skips"
  fi

  tui_perf="$out_root/timings.tui_perf.txt"
  if [[ -f "$run_log" ]]; then
    use_req_issued=0
    use_resp_issued=0
    if grep -q "tui: pane view request issued" "$run_log"; then
      use_req_issued=1
    fi
    if grep -q "tui: pane view response " "$run_log"; then
      use_resp_issued=1
    fi
    LC_ALL=C awk -v use_req_issued="$use_req_issued" -v use_resp_issued="$use_resp_issued" '
    function dur_ms(s) {
      if (s == "" || s == "-") { return "" }
      if (s ~ /µs$/) { sub(/µs$/, "", s); return (s + 0) / 1000 }
      if (s ~ /us$/) { sub(/us$/, "", s); return (s + 0) / 1000 }
      if (s ~ /ms$/) { sub(/ms$/, "", s); return s + 0 }
      if (s ~ /s$/) { sub(/s$/, "", s); return (s + 0) * 1000 }
      return s + 0
    }
    function upd(val, minv, maxv, sumv, cntv) {
      if (val == "" || val == "-") { return minv "\t" maxv "\t" sumv "\t" cntv }
      v = val + 0
      if (cntv == 0 || v < minv) { minv = v }
      if (cntv == 0 || v > maxv) { maxv = v }
      sumv += v
      cntv += 1
      return minv "\t" maxv "\t" sumv "\t" cntv
    }
    function strip_esc(s) {
      gsub(/\x1b\[[0-9;]*[A-Za-z]/, "", s)
      return s
    }
    {
      line = strip_esc($0)
      if (use_req_issued == 1) {
        if (line ~ /tui: pane view request issued/) {
          val=""
          for (i=1;i<=NF;i++) {
            if ($i ~ /^event_to_req=/) { val=substr($i,14) }
            if ($i ~ /^delay_event_to_req=/) { val=substr($i,20) }
          }
          ms = dur_ms(val)
          if (ms != "") {
            split(upd(ms, min_event_req, max_event_req, sum_event_req, cnt_event_req), a, "\t")
            min_event_req=a[1]; max_event_req=a[2]; sum_event_req=a[3]; cnt_event_req=a[4]
          }
        }
      } else if (line ~ /tui: pane view req slow/) {
        val=""
        for (i=1;i<=NF;i++) {
          if ($i ~ /^delay_event_to_req=/) { val=substr($i,20) }
        }
        ms = dur_ms(val)
        if (ms != "") {
          split(upd(ms, min_event_req, max_event_req, sum_event_req, cnt_event_req), a, "\t")
          min_event_req=a[1]; max_event_req=a[2]; sum_event_req=a[3]; cnt_event_req=a[4]
        }
      }

      if (use_resp_issued == 1) {
        if (line ~ /tui: pane view response /) {
          val_resp=""; val_req=""
          for (i=1;i<=NF;i++) {
            if ($i ~ /^event_to_resp=/) { val_resp=substr($i,15) }
            if ($i ~ /^delay_event_to_resp=/) { val_resp=substr($i,21) }
            if ($i ~ /^req_dur=/) { val_req=substr($i,9) }
          }
          msr = dur_ms(val_resp)
          if (msr != "") {
            split(upd(msr, min_event_resp, max_event_resp, sum_event_resp, cnt_event_resp), a, "\t")
            min_event_resp=a[1]; max_event_resp=a[2]; sum_event_resp=a[3]; cnt_event_resp=a[4]
          }
          msq = dur_ms(val_req)
          if (msq != "") {
            split(upd(msq, min_req_resp, max_req_resp, sum_req_resp, cnt_req_resp), a, "\t")
            min_req_resp=a[1]; max_req_resp=a[2]; sum_req_resp=a[3]; cnt_req_resp=a[4]
          }
        }
      } else if (line ~ /tui: pane view resp slow/) {
        val_resp=""; val_req=""
        for (i=1;i<=NF;i++) {
          if ($i ~ /^delay_event_to_resp=/) { val_resp=substr($i,21) }
          if ($i ~ /^delay_req_to_resp=/) { val_req=substr($i,19) }
        }
        msr = dur_ms(val_resp)
        if (msr != "") {
          split(upd(msr, min_event_resp, max_event_resp, sum_event_resp, cnt_event_resp), a, "\t")
          min_event_resp=a[1]; max_event_resp=a[2]; sum_event_resp=a[3]; cnt_event_resp=a[4]
        }
        msq = dur_ms(val_req)
        if (msq != "") {
          split(upd(msq, min_req_resp, max_req_resp, sum_req_resp, cnt_req_resp), a, "\t")
          min_req_resp=a[1]; max_req_resp=a[2]; sum_req_resp=a[3]; cnt_req_resp=a[4]
        }
      }
    }
    END {
      print "tui_paneview_latency_ms:"
      src_req = (use_req_issued == 1 ? "request_issued" : "slow_only")
      src_resp = (use_resp_issued == 1 ? "response" : "slow_only")
      printf "  source_event_to_req: %s\n", src_req
      printf "  source_req_to_resp: %s\n", src_resp
      if (cnt_event_req > 0) { printf "  event_to_req: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_event_req, min_event_req, max_event_req, sum_event_req/cnt_event_req } else { print "  event_to_req: no data" }
      if (cnt_event_resp > 0) { printf "  event_to_resp: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_event_resp, min_event_resp, max_event_resp, sum_event_resp/cnt_event_resp } else { print "  event_to_resp: no data" }
      if (cnt_req_resp > 0) { printf "  req_to_resp: count=%d min=%.3f max=%.3f avg=%.3f\n", cnt_req_resp, min_req_resp, max_req_resp, sum_req_resp/cnt_req_resp } else { print "  req_to_resp: no data" }
    }' "$run_log" > "$tui_perf"
  fi

  {
    echo
    echo "timings_coverage: $coverage_out"
    cat "$coverage_out"
    if [[ -f "$input_output_out" ]]; then
      echo
      echo "timings_input_output: $input_output_out"
      cat "$input_output_out"
    fi
    echo
    echo "timings_top_slow: $top_slow"
    if [[ -f "$tui_skips" ]]; then
      echo
      echo "timings_tui_skips: $tui_skips"
      cat "$tui_skips"
    fi
    if [[ -f "$tui_perf" ]]; then
      echo
      echo "timings_tui_perf: $tui_perf"
      cat "$tui_perf"
    fi
  } >> "$report"
fi

cat <<EOF

Saved profiler artifacts to: $out_root
- cpu.pprof / heap.pprof
- cpu.top.txt / heap.top.txt
- report.txt
- run.log
- daemon.log
- DONE (marker file)
$( [[ -n "$fgprof_secs" ]] && echo "- fgprof.pprof" )
$( [[ -n "$trace_secs" ]] && echo "- trace.out" )
$( [[ "$enable_block" == true ]] && echo "- block.pprof / block.top.txt" )
$( [[ "$enable_mutex" == true ]] && echo "- mutex.pprof / mutex.top.txt" )
EOF
